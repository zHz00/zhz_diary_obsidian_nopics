Тайна одного access violation
==============================

   
 2024-01-23, 04:37   
  Обновил программу у пользователя -- начала падать без сообщений об ошибке.   
   
 Это очень неудобная ситуация, потому что у пользователя не стоит отладчик. Что там, где падает? Почему?   
   
 Штош, берём  [procdump](Кратчайшее%20руководство%20по%20отладке%20при%20помощи%20дампов%20памяти)  . Запускаем, скачиваем дамп, включаем вижуал студию.   
   
 Наконец вижу сообщение, аксесс виолейшн по адресу 0x00000013. Как говорили в старину, "память не может быть "read".   
   
 В строчках, где возникла ошибка, происходит обращение к буферу символов. Но и буфер символов имеет нормальный адрес (не тот) и содержимое его я вижу хорошо. Что же там происходит? Приведу пример текста.   
   
 pObject->Func1();// ошибка где-то здесь   
 //...   
 void CClass::Func1()   
 {   
 //много операторов   
 this->Func2();//ошибка где-то здесь   
 }   
 void CClass::Func2()   
 {   
 //манипуляции со строками, ошибка где-то здесь   
 this->state=0;   
 }   
   
 Особенность вижуал студии в том, что она подсвечивает не ту строчку, что только что выполнила, а следующую. Это правильно, потому что при безошибочном выполнении программы следующая строчка интереснее, чем предыдущая. Но в случае с ошибками это сбивает с толку, потому что указывает не на ту строчку, где ошибка произошла.   
   
 Чтобы выяснить доподлинно, что выполняется, а что нет, я расставил отладочную печать во всех этих функциях и выяснил, что выполнение прекрасно доходит до строчки this->state=0; Таким образом, никаких ошибок со строками и массивами не происходит. Кто же генерирует аксесс виолейшн? Вот эта самая последняя строка.   
   
 Я думаю, все уже догадались. this был равен NULL.   
   
 В обновлённой версии программы требовались особые значения в конфигурационном файле, которые я по недосмотру не указал. Логика программы такова, что на pObject память выделяется только при правильных значениях. А если их нет, то pObject==NULL.   
   
 Что меня в этой ситуации удивило, так это то, что вызов методов по нулевому указателю не привёл к исключению сам по себе. Надо было дождаться именно обращения к полю. Это можно об'яснить, потому что все методы (кроме виртуальных) имеют фиксированные адреса, и настоящего разыменования указателя не происходит. Метод вызывается по известному адресу и получает NULL как this. Дальше он работает без обращений к полям и вызывает следующий метод, который тоже получает NULL. И только там, в конце, когда происходит действительное обращение к полю, этот this разыменовывается, и происходит генерация исключения...   
   
 Обращаю также внимание, что адрес разыменования не равен нулю, а равен другому числу. Это связано с тем, что state имеет смещение относительно начала об'екта.   
    
 <https://diary.ru/~zHz00/p221887140_tajna-odnogo-access-violation.htm>   
   
 Теги:   
 [[Программирование]]   
 [[Борьба с техникой]]   
 ID: p221887140