Доверенность от мертвеца
=========================

   
 2015-02-11, 23:47   
  Эх, говорила мне мама в детстве, что межпроцессное взаимодействие -- сложная тема и туда лучше не соваться!   
   
 Дано: система, проводящая измерения по своим внутренним каналам и внешний блок, проводящий измерение по одному своему каналу. Взаимодействие с блоком выглядит так -- мы направляем блоку запросы "сколько у тебя?", "сколько у тебя?", а он отвечает.   
   
 Чтобы не нарушать связность основной программы, управление внешним блоком было реализовано в отдельном классе, запросы посылались в отдельном потоке, а значения записывались во внутренний буфер экземпляра класса. Получение данных было реализовано с помощью отдельного метода. Алгоритм работы имел примерно следующий вид:   
   
 
```
Блок.Начать();// запустить поток измерений  
/\* измерения основной системой \*/<br>Блок.Закончить();// закончить поток измерений  
Блок.ОтдайДанные();
```
   
   
 При работе на одном компьютере всё отрабатывало хорошо, однако было замечено, что поток, обслуживающий измерения, запускается лишь спустя ДВЕ СЕКУНДЫ после того, как он должен быть запущен. Это в некотором смысле плохо, т.к. нарушается связанность по времени с остальными измерениями. Пришлось поставить дополнительную проверку -- пока измерения не начались у блока, свои не начинать.   
   
 
```
Блок.Начать();  
while(!Блок.Меряет())  
	Sleep(1);//спать  
/\* измерения основной системой \*/  
Блок.Закончить();  
Блок.ОтдайДанные();
```
   
   
 Заканчивался поток тоже спустя две секунды по отношению к тому времени, когда должен был завершиться, но это было нестрашно, поскольку данные я получал всё равно на момент окончания измерений и что потом там было намерено что-то ещё, меня не волновало.   
   
 На другом компьютере программа начала внезапно вылетать. Причём на этапе ОтдайДанные(). И не где-нибудь, а на индексации массива. Я грешил на неправильные индексы, но вылетало при индексе ноль. Догадались?   
   
 ОКАЗАЛОСЬ, что на втором компьютере задержек почему-то не возникало, и там поток завершался ЕЩЁ ДО того, как происходила выемка данных. А поток, завершаясь,  **освобождал память**  ! (я не осознавал, что он ДЕЙСТВИТЕЛЬНО это делает -- поэтому был слегка удивлён). Что приводило к попытке получения данных по адресу, по которому уже ничего не было.   
   
 Самая надзо-надзо (загадка) тут -- почему на одном компьютере задержки возникают, а на другом нет? Оба компьютера имеют абсолютно одинаковую аппаратную конфигурацию и предустановленное ПО.   
    
 <https://diary.ru/~zHz00/p202633752_doverennost-ot-mertveca.htm>   
   
 Теги:   
 [[Программирование]]   
 [[Борьба с техникой]]   
 ID: p202633752