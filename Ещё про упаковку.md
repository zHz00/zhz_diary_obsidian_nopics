Ещё про упаковку
=================

   
 2016-12-11, 23:59   
  Я  [написал](Первый%20--%20шаг%20вперёд,%20и%20в%20рай)  о проблеме, которая может возникнуть из-за неожиданного выравнивания полей структуры, но не написал, что же с этим делать.   
   
 Сначала несколько важных замечаний:   
 * Встретил я указанную проблему в компиляторе GCC под ARM.
* По документации результат #pragma pack распространяется на упаковку  *полей структуры*  , описание которой идёт сразу после директивы. То есть, по идее, значение упаковки не должно было переноситься на дальнейшие структуры. Однако оно переносилось.
* #pragma pack -- микрософтовская штучка и была добавлена в GCC для совместимости. В компиляторах от микрософт она может работать несколько иначе. В GCC есть более мощный аналог -- \_\_attribute\_\_((packed(...)))

   
   
 Решение такое. Надо просто принудительно при описании каждой структуры перед ней прописывать желаемую упаковку. Однако тут появляется проблема -- если после нашей структуры будут другие структуры, они получат уже новую упаковку, что потенциально попортит жизнь библиотекам, заголовочные файлы которых включены после нашего. Попортят тем же способом, каким кто-то попортил жизнь нам. Однако разработчики предусмотрели на этот случай возможность сохранения и восстановления значения упаковки. Итак, вот что надо делать при описании  **каждой**  структуры:   
   
 
```
#pragma pack(push)  
#pragma pack()<br>//#pragma pack(N)<br>struct A<br>	{<br>		//...<br>	};  
#pragma pack(pop)
```
   
   
 pack(push) в начале сохранит, а pack(pop) в конце восстановит старое значение упаковки (вдруг оно будет кому-то нужно?).   
   
 pack() без параметров установит значение упаковки по-умолчанию, которое можно настроить перед началом компиляции (подробнее  [тут](https://gcc.gnu.org/onlinedocs/gcc-4.4.4/gcc/Structure_002dPacking-Pragmas.html)  ), что позволит гибко настраивать упаковку для различных архитектур. Если же нужна конкретная упаковка для данной структуры, можно написать #pragma pack (N), где вместо N должно стоять число 1, 2 или 4 (компиляторы микрософт для 64-битных систем также поддерживают 8 и 16). Идентификатор, сделанный через #define, вместо N подставить нельзя.   
    
 <https://diary.ru/~zHz00/p211315726_ewyo-pro-upakovku.htm>   
   
 Теги:   
 [[Программирование]]   
 ID: p211315726