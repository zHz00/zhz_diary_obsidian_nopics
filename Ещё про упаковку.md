Ещё про упаковку
================

  
2016-12-11, 23:59  
 Я  [написал](Первый%20--%20шаг%20вперёд,%20и%20в%20рай)  о проблеме, которая может возникнуть из-за неожиданного выравнивания полей структуры, но не написал, что же с этим делать.   
   
 Сначала несколько важных замечаний:   
 * Встретил я указанную проблему в компиляторе GCC под ARM.
* По документации результат #pragma pack распространяется на упаковку  *полей структуры*  , описание которой идёт сразу после директивы. То есть, по идее, значение упаковки не должно было переноситься на дальнейшие структуры. Однако оно переносилось.
* #pragma pack -- микрософтовская штучка и была добавлена в GCC для совместимости. В компиляторах от микрософт она может работать несколько иначе. В GCC есть более мощный аналог -- \_\_attribute\_\_((packed(...)))

   
   
 Решение такое. Надо просто принудительно при описании каждой структуры перед ней прописывать желаемую упаковку. Однако тут появляется проблема -- если после нашей структуры будут другие структуры, они получат уже новую упаковку, что потенциально попортит жизнь библиотекам, заголовочные файлы которых включены после нашего. Попортят тем же способом, каким кто-то попортил жизнь нам. Однако разработчики предусмотрели на этот случай возможность сохранения и восстановления значения упаковки. Итак, вот что надо делать при описании  **каждой**  структуры:   
   
 
```
#pragma pack(push)  
#pragma pack()
//#pragma pack(N)
struct A
	{
		//...
	};  
#pragma pack(pop)
```
   
   
 pack(push) в начале сохранит, а pack(pop) в конце восстановит старое значение упаковки (вдруг оно будет кому-то нужно?).   
   
 pack() без параметров установит значение упаковки по-умолчанию, которое можно настроить перед началом компиляции (подробнее  [тут](http://gcc.gnu.org/onlinedocs/gcc-4.4.4/gcc/Structure_002dPacking-Pragmas.html)  ), что позволит гибко настраивать упаковку для различных архитектур. Если же нужна конкретная упаковка для данной структуры, можно написать #pragma pack (N), где вместо N должно стоять число 1, 2 или 4 (компиляторы микрософт для 64-битных систем также поддерживают 8 и 16). Идентификатор, сделанный через #define, вместо N подставить нельзя.   
  
<https://diary.ru/~zHz00/p211315726_ewyo-pro-upakovku.htm>  
  
Теги:  
[[Программирование]]  
ID: p211315726  


Комментарии: 4
--------------

  


---



|         #         |              Дата              |                     Автор                     |           ID           |
| --- | --- | --- | --- |
| (1/4) | 2016-12-12, 05:03 | RetXiRT suiR@ttig@$ | c715753363 |

  
  Даблпост.    
 ^c715753363

---



|         #         |              Дата              |                     Автор                     |           ID           |
| --- | --- | --- | --- |
| (2/4) | 2016-12-12, 08:01 | zHz00 | c715754198 |

  
 Спасибо, удалил лишний.   
 ^c715754198

---



|         #         |              Дата              |                     Автор                     |           ID           |
| --- | --- | --- | --- |
| (3/4) | 2016-12-12, 23:14 | himself | c715787950 |

  
 Слышал байку, что в описании директивы pragma в стандарте C++ сказано: "Компилятор волен трактовать директиву как ему вздумается", поэтому первые версии gcc, встречая директиву pragma, запускали какую-то линуксовую игру.   
 ^c715787950

---



|         #         |              Дата              |                     Автор                     |           ID           |
| --- | --- | --- | --- |
| (4/4) | 2016-12-12, 23:31 | zHz00 | c715788819 |

  
  [himself](http://himself.diary.ru "void")  , АХАХАХАХА.   
 ^c715788819