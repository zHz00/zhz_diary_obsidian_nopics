Что посеешь, то и пожмёшь
=========================

  
2017-02-15, 23:58  
 Одним проектом я не занимался год. Потом открыл. Ох, как всё запущенно.   
   
 Я знал и знаю некоторые правила хорошего стиля программирования, которые я сам иногда нарушаю. И открыв этот проект я огрёб по полной. Я не знаю, почему я тогда нарушил парочку базовых правил, но сейчас мне это сильно добавило работы. Правила все давно знают, но всё же их укажу:   
   
 1. У переменных должны быть понятные имена. Это касается не только переменных типа \_, asdbsd и Burrrrp (хотя игроку в НетХак последняя будет весьма понятна) -- тут всё ясно. Название может иметь отношение к реальной ситуации, но имеет шанс быть воспринятым неправильно. Так, у меня в программе была переменная по имени need\_count. Я долго думал, что это число раз, которые надо (need) посчитать (count) что-то. Однако на самом деле эта переменна обозначало то, НАДО считать (1) или НЕ НАДО (0).   
   
 2. Отсюда вытекает второе правило -- тип переменной должен соответствовать её назначению. Переменная из п.1 имела тип int. Хотя гораздо понятнее всё было бы, если бы я сделал её типа \_Bool (это было в той части проекта, которая работала на микроконтроллере, а она написана на голом Си-99, поэтому именно \_Bool, а не bool). Для МК, это, правда, простительно, т.к. int будет быстрее обрабатываться в ряде случаев.   
 Примечание. Беззнаковые типы при совместном использовании со знаковыми таят в себе гремучую бомбу:  [zhz00.diary.ru/p211118163.htm](Зазеркалье)    
   
 3. А третье правило -- не следует повторно использовать ту же переменную для других целей. Хотя для переменных типа x, y, i особой разницы нету, сколько раз их использовать. Но повторное использование более специальных переменных часто ведёт к нарушению п.1. То, на чём конкретно напоролся я -- WriteFile возвращает через указатель число записанных байтов. Для этого я использовал переменную с подходящим именем written. Но потом мне надо было читать данные при помощи ReadFile. Как не трудно догадаться, он тоже через указатель возвращает число байтов, но уже прочтённых. Видимо тогда я решил сэкономить четыре байта. Ну вот нафига? Да-да, именно так. Я написал --   
   
 ReadFile(hFile,size,&written,NULL);   
   
 Потом очень удивился -- зачем я после чтения проверяю число записанных байт?.. Это уже было в части программы для ПК, так что тут прощения мне нет -- под ПК экономить нечего.   
   
 Это я тогда был не в своём уме или так вырос за год, что считаю дикостью то, что сделал своими же руками?   
   
 Но кое-от-чего чего я пока избавиться не смог -- так это от применения операции ?: . Очень её люблю, хотя она сильно усложняет чтение текста.   
  
<https://diary.ru/~zHz00/p211994243_chto-poseesh-to-i-pozhmyosh.htm>  
  
Теги:  
[[Программирование]]  
[[Говнокод]]  
[[Очевидное-невероятное]]  
ID: p211994243  


Комментарии: 15
---------------

  


---



|         #         |              Дата              |                     Автор                     |           ID           |
| --- | --- | --- | --- |
| (1/15) | 2017-02-16, 11:16 | Knows Ajed | c718433606 |

  
 Если Вы смотрите на то, что написали 5 лет назад и считаете это полным дерьмом, то всё не так уж плохо.   
   
 Всё по-настоящему плохо, когда Вы смотрите на то, что написали 5 лет назад и считаете это гениальным.   
 ^c718433606

---



|         #         |              Дата              |                     Автор                     |           ID           |
| --- | --- | --- | --- |
| (2/15) | 2017-02-16, 12:30 | zHz00 | c718436409 |

  
  [Knows Ajed](http://Who-Knows-Ajed.diary.ru "Who Knows Ajed?")  , гениальными я обычно считаю свои старые посты на дайари. Не все, но некоторые. Хотя то, что я писал 5 лет наза,д мне нравится меньше, чем то, что я писал 3 года назад. А вот дальше улучшений что-то нет -- в смысле, круче уже некуда.   
 ^c718436409

---



|         #         |              Дата              |                     Автор                     |           ID           |
| --- | --- | --- | --- |
| (3/15) | 2017-02-16, 16:43 | korrshun | c718445623 |

  
 тернарный оператор я нежно люблю, но во избежание граблей мы договорились, что нельзя вызывать мутирующие функции в ветвях.   
 ^c718445623

---



|         #         |              Дата              |                     Автор                     |           ID           |
| --- | --- | --- | --- |
| (4/15) | 2017-02-16, 17:51 | zHz00 | c718448310 |

  
  [korrshun](http://Igel-kun.diary.ru "kimi wo shiranai monogatari")  , что такое мутирующие функции и какое они имеют отношение к достопочтенному тернарному оператору?   
 ^c718448310

---



|         #         |              Дата              |                     Автор                     |           ID           |
| --- | --- | --- | --- |
| (5/15) | 2017-02-16, 18:14 | zHz00 | c718449248 |

  
 Это типа x=(y>0?sin:cos)(t); ?   
 ^c718449248

---



|         #         |              Дата              |                     Автор                     |           ID           |
| --- | --- | --- | --- |
| (6/15) | 2017-02-16, 18:36 | korrshun | c718450232 |

  
 В случае с js это несёт ещё одну важную гигиеническую цель - чистые функции обычно синхронные (получают и возвращают значение, а не Promise или не ожидают на вход каких-то callcack), и не требуют особых приседаний в виде написания доп. кода, который обработает ошибки, вылетевшие из них.   
   
 Примеры пусть и на js, но достаточно поясняют идею.   
   
 ну например ни в коем случае не надо писать:   
   
 result = x ? response.send(JSON.stringify(x)) : response.sendStatus(404)   
   
 А вот так, писать можно:   
   
 style = foo ? calcStyle(foo) : getDefaultStyle()   
   
 потому что эти функции чистые и не меняют мир вокруг.   
 ^c718450232

---



|         #         |              Дата              |                     Автор                     |           ID           |
| --- | --- | --- | --- |
| (7/15) | 2017-02-16, 19:03 | zHz00 | c718451376 |

  
 А, мутирующие функции -- это НЕ ЧИСТЫЕ.   
 ^c718451376

---



|         #         |              Дата              |                     Автор                     |           ID           |
| --- | --- | --- | --- |
| (8/15) | 2017-02-16, 21:12 | himself | c718456927 |

  
  *Отсюда вытекает второе правило -- тип переменной должен соответствовать её назначению.*    
 Есть даже более жёсткое правило, которое на мой взгляд удобно: тип переменной должен \*точно\* определять, что в ней хранится.   
 Иными словами, переменные типа инт годятся только для счётчиков, но не для длины (для неё нужен typedef int pixelWidth), ширины, а тем более переменных, которые используют его хитро, например, децибелл, записанных в десятых долях (215 = 21.5 Дб).   
   
 Это не только делает код читаемым (pixelWidth width, decidB db), облегчает проверку типов (если ты присваиваешь dB к width, ты действуешь неправильно), мало того, это определяет  *конкретное место, где описано, что хранится в типе*  . А именно, там, где тип определён. Там ты даёшь все комментарии о том, как он устроен. Из любого места, где тип используется, ты можешь туда перейти одним щелчком.   
   
 А не так, что у людей объявлен в функции параметр (int dbInDecimalParts) с комментарием, в соседней функции такой же, с ещё одним таким же комментарием, в третьей комментарий забыли, кто-то вышел сразу на третью, передал туда децибеллы в единицах.   
   
 Нет, любой параметр, который не счётчик - должен быть назван, и желательно (если язык позволяет) жёстко типизирован, т.е. чтобы присваивания от родительского типа не работали без каста. Тогда человек будет вынужден пойти и посмотреть, что это за тип, и прочтёт объяснения.   
   
 Это позволяет легко найти все места в коде, где используется конкретно эта структура типа, если ты её меняешь. И это упорядочивает код, т.к. строгое объявление должно логически к кому-то принадлежать, и перед тобой сразу встаёт вопрос, кто главный по этому типу. Внезапно выясняется, что какие-то типы на самом деле имеют двух хозяев, и на самом деле это два типа двух разных библиотек, которые были слиты только потому, что выглядели похоже и передавались друг другу. В общем, сплошные ништяки.   
 ^c718456927

---



|         #         |              Дата              |                     Автор                     |           ID           |
| --- | --- | --- | --- |
| (9/15) | 2017-02-16, 21:22 | zHz00 | c718457419 |

  
  [himself](http://himself.diary.ru "void")  , идея классная, но свободолюбивый я возражает. Надо это в Rust ввести. Там много подобных эмм... "ограничителей".   
 ^c718457419

---



|         #         |              Дата              |                     Автор                     |           ID           |
| --- | --- | --- | --- |
| (10/15) | 2017-02-16, 21:36 | himself | c718458175 |

  
  [zHz00](https://zHz00.diary.ru "Untitled")  , она как раз... освобождает ![:)](http://static.diary.ru/picture/3.gif)   
 Как и большинство хороших правил, её необязательно применять везде, можно только там, где хочется. Но со временем, когда к ней привыкаешь, то начинает хотеться так делать. Когда собираешься объявить нетривиальное поле, тут же в голове всплывают гадости: многократная документация где попало, неуверенность, где же формат документирован и документирован ли вообще; путаница, отладка из-за того, что кто-то не понял. И тут же хочется вот взять и объявить аккуратненько так ![:)](http://static.diary.ru/picture/3.gif)   
 ^c718458175

---



|         #         |              Дата              |                     Автор                     |           ID           |
| --- | --- | --- | --- |
| (11/15) | 2017-02-16, 22:03 | zHz00 | c718459597 |

  
  [himself](http://himself.diary.ru "void")  ,   
 >> она как раз... освобождает ![:)](http://static.diary.ru/picture/3.gif) <...> Но со временем, когда к ней привыкаешь, то начинает хотеться так делать.   
   
 Прям как сегодняшний пост Эволюции про нравственность.   
 ^c718459597

---



|         #         |              Дата              |                     Автор                     |           ID           |
| --- | --- | --- | --- |
| (12/15) | 2017-02-17, 13:20 | korrshun | c718480159 |

  
  Надо это в Rust ввести    
   
 Там уже есть. Алгебраические типы зовётся.   
   
  Есть даже более жёсткое правило, которое на мой взгляд удобно: тип переменной должен \*точно\* определять, что в ней хранится.    
   
 а давайте тогда сразу haskell!   
 Есть там одна фиговина по имени Ivory - с её помощью можно потом сишечку генерить из хаскелля, чтобы типобезопасно и красиво.   
 ^c718480159

---



|         #         |              Дата              |                     Автор                     |           ID           |
| --- | --- | --- | --- |
| (13/15) | 2017-02-20, 10:34 | Knows Ajed | c718594590 |

  
 Я безнадёжно испорченный человек. Из-за парадокса Блаба, для меня   
 ("Haskell" == "Brainfuck") == true   
 ^c718594590

---



|         #         |              Дата              |                     Автор                     |           ID           |
| --- | --- | --- | --- |
| (14/15) | 2017-02-20, 12:47 | zHz00 | c718598616 |

  
 Ух ты, какая штука. Про парадокс Блаба не слышал!   
   
 Я кстати Хаскелль так и не осилил. Не придумал себе задач под него, потому что мозг в его парадигме не работает. Тут замкнутый круг. Наверное, надо сначала учебные задачи делать, тогда мозг работать в парадигме начнёт. А дальше и задачи появятся.   
 ^c718598616

---



|         #         |              Дата              |                     Автор                     |           ID           |
| --- | --- | --- | --- |
| (15/15) | 2017-02-20, 15:39 | Knows Ajed | c718604633 |

  
  [zHz00](https://zHz00.diary.ru "Untitled")  , да, по сути, тот же парадокс Блаба. ) Плюс-минус. )   
 ^c718604633