Первый -- шаг вперёд, и в рай
=============================

  
2016-12-06, 23:58  
 Удивительную вещь встретил. Передаю в функцию указатель на экземпляр структуры, а приходит вместо исходных значений -- мусор.   
   
 Смотрю, адреса в памяти совпадают, т.к. указатель передался правильно. Смотрю значения в памяти -- не меняются. Так почему же я передаю одни значения, а получаю другие?   
   
 Значит, они по-разному интерпретируются! Но структура одна же. Я включил её определение в .h файле в два .c файла -- в главный файл и в файл с определением функции, которую я вызываю.   
   
 Я попробовал поменять типы данных с однобайтных на двухбайтные. И оказалось, что теперь половина значений доходит правильно, но располагается в других переменных!   
   
 Короче говоря, дело было в выравнивании данных в памяти. В главном файле где-то в начале (или в одном из заголовков) было установлено #pragma pack(2), а во втором файле -- #pragma pack(4). И уже ПОСЛЕ этого был включен мой заголовочный файл и описанием структуры. В итоге главный файл думал, что выравнивать поля надо по 2 байта на переменную, а второй файл, что по четыре! Т.е. структуры имели одинаковое имя, но были несовместимы двоично! Я непосредственно перед описанием структуры в заголовочном файле поставил #pragma pack(4) и всё стало зашибись.   
   
  [(пример, иллюстрирующий #pragma pack для тех, кто не в курсе)](https://zHz00.diary.ru/p211251022.htm?index=1#linkmore211251022m1)      
  **Пример, иллюстрирующий #pragma pack для тех, кто не в курсе:**    
 
```
  
#pragma pack(2)  
struct A1  
	{  
		char a;  
		short int b;//sizeof(short int)==2  
		int c;//sizeof(int)==4  
	};  
  
#pragma pack(4)  
struct A2  
	{  
		char a;  
		short int b;//sizeof(short int)==2  
		int c;//sizeof(int)==4  
	};  
  
struct A1 *a1=0x1000;  
struct A2 *a2=0x2000;  
// пусть мы уверены, что в памяти ничего нет и мы можем располагать данные по произвольным адресам  
  
/*  
теперь:  
&(a1->a) == 0x1000  
&(a2->a) == 0x2000  
  
&(a1->b) == 0x1002 //a занимает только 1 байт, но у нас выравнивание по границам слов, поэтому b имеет смещение 2 байта от начала, а не 1  
&(a2->b) == 0x2004 // (!) а тут 4 байта смещение от начала  
  
&(a1->c) == 0x1004 // b занимает 2 байта и располагается в памяти вплотную к c  
&(a2->c) == 0x2008 // b занимает ВСЕГО 2 байта, поэтому нужен промежуток, т.к. у нас условие, что выравнивание по двойным словам (4 байта), поэтому c получает смещение 8.  
*/  

```
     
  
<https://diary.ru/~zHz00/p211251022_pervyj-shag-vperyod-i-v-raj.htm>  
  
Теги:  
[[Программирование]]  
ID: p211251022  


(Комментариев нет)
------------------