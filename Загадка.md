Загадка
=======

  
2011-11-17, 23:04  
 Сделал говнокод. Функционирует так, как мне надо. Попробуйте угадать, что он делает.   
   
 
```
sFmt.Format(_T("%%.%de"),nDigits-1);  
sBuf.Format(_T(sFmt), fValue);
sscanf(sBuf,"%lf",&fValue);
// шаманим-шаманим
sFmt.Format(
	_T("%%.%df\t"),
		(int)(fabs(fValue)>=pow((double)10,(int)(nDigits-1))?0:
			(FLT_MIN>-1+nDigits-floor(fabs(fValue)?-1+nDigits:
				log10(fabs(fValue))))));
sBuf.Format(_T(sFmt),fValue);  
sItem += sBuf;
```
   
   
 Типы переменных:   
 sItem, sBuf, sFmt -- CString   
 fValue -- float   
 nDigits -- int   
   
 В принципе, этот кусок выполняется в цикле и на самом деле nDigits выбираются из массива типа aDigits[ix], а fValue в каждой итерации разный, потому что тоже выбран из массива, но это неважно.   
   
 Форматирование такое, потому что не хотел, чтобы за конец строки вылезало. Считайте меня Маяковским.   
   
 Ответ через трое суток. Не думаю, что кто-то захочет отписаться, но если такие найдутся, то ответ, пожалуйста, прячьте в тэг MORE, чтобы не подсказывать другим потенциальным желающим.   
  [(показать ответ)](https://zHz00.diary.ru/p169376440.htm?index=1#linkmore169376440m1)      
 Ответ:   
 Код добавляет (конкатенирует) к sItem число с заданным количеством значащих цифр, а вместо нуля добавляет "0". Исходное число содержится в sBuf, где оно и приводится к необходимому виду.     
   
 Можно ли было сделать проще?   
  
<https://diary.ru/~zHz00/p169376440_zagadka.htm>  
  
Теги:  
[[Программирование]]  
[[Говнокод]]  
ID: p169376440  


Комментарии: 6
--------------

  


---



|         #         |              Дата              |                     Автор                     |           ID           |
| --- | --- | --- | --- |
| (1/6) | 2011-11-18, 01:27 | Гость | c574742236 |

  
  [читать дальше](https://zHz00.diary.ru/p169376440.htm?index=1#linkmore169376440m1)    sFmt.Format(\_T("%%.%de"),nDigits-1);sBuf.Format(\_T(sFmt), fValue);sscanf(sBuf,"%lf",&fValue);   
 Итак, первые три строчки вполне можно объединить в одну:   
 fValue = std::floor(std::abs(static\_cast<double>(fValue) \* pow(10.0, nDigits-1))) \* (fValue >= 0 ? 1 : -1);   
 В пространстве имён std в C++ есть все математические функции без префиксов, перегруженные для стандартных типов аргументов.   
   
 Функция printf может принимать флаг "-" но он ставится сразу после знака "%". Если майкрософт не начудило с этим, то из того, что nDigits-1 в первой части используется в поле точности я делаю вывод что nDigits - 1 >= 0 или, соответственно, nDigits >= 1.   
   
 Я не знаю проще ли это, но быстрее — это точно. Тут нет динамического выделения памяти и вместо строковых операций используются операции сопроцессора. Думаю, что это быстрее раз эдак в 100 (это к слову о цикле, в котором это выполняется).   
   
 Значит вторая часть делает следующее:   
 (1) если число больше ширины поля nDigits - 1, то оставляем в поле точности 0.   
 (2) если число больше минимального нормализованного числа, то (ОМГ) всё равно оставляем в точности 0 т.к. nDigits - 1 - floor(nDigits - 1) == 0.   
 (3) если число меньше минимального нормализованного числа (т.е. не нормализованное число), то уменьшаем ширину поля на десятичный логарифм от числа, который, конечно же, отрицательный (т.е. увеличиваем точность). Причём увеличиваем на число явно достаточное (по крайней мере большее nDigits - 1 + FLT\_MIN\_10\_EXP.   
   
 Я хочу напомнить о том, что printf принимает модификатор точности \* ("звёздочка"). В этом случае точность передаётся отдельным аргументом, который предшествует аргументу со значением.   
   
 Не проверял это, но полагаю что следующий код эквивалентен:   
 sBuf.Format(\_T("%.\*f\t"), std::max(nDigits - 1, static\_cast<int>(nDigits - 1 + std::log10(std::abs(fValue)))), fValue);   
     
   
 // цудзуку   
 ^c574742236

---



|         #         |              Дата              |                     Автор                     |           ID           |
| --- | --- | --- | --- |
| (2/6) | 2011-11-18, 01:28 | Гость | c574742338 |

  
  [И приятная мелочь](https://zHz00.diary.ru/p169376440.htm?index=1#linkmore169376440m1)    Так же в стандарте чёрным по белому написано: «The type of a floating literal is double unless explicitly specified by a suffix» (ISO/IEC 14882:1998(E) p. 18). Т.е. 10.0 --- уже double. Можно сказать 10.0F для float или 10.0L для long double.   
   
 Особый респект за использование преобразований типов а ля си, которые объявлены не рекомендуемыми. Технический отчёт к стандарту (номер забыл) рекомендует выводить предупреждения при их использовании.     
   
 // можно догадаться кто   
 ^c574742338

---



|         #         |              Дата              |                     Автор                     |           ID           |
| --- | --- | --- | --- |
| (3/6) | 2011-11-18, 04:20 | Гость | c574749188 |

  
  [читать дальше](https://zHz00.diary.ru/p169376440.htm?index=1#linkmore169376440m1)    Я нашёл у себя в предложенном несколько ошибок (поторопился). Собственно, это подтолкнуло меня к по всей видимости не верному выводу. Так что я временно снимаю тот ответ, который там приведён.   
   
 Всё же приведу исправления ошибок:   
 fValue = std::floor(std::abs(static\_cast<double>(fValue) \* pow(10.0, (nDigits - 1) - std::log10(std::abs(fValue))))) \* (fValue >= 0 ? 1 : -1) / pow(10.0, (nDigits - 1) - std::log10(std::abs(fValue)));   
   
 Так же приведённый код работает не во всей области, покрываемой числами с плавающей точкой (только в некоторой окрестности нуля).   
   
 sBuf.Format(\_T("%.\*f\t"), std::max(nDigits - 1, static\_cast<int>(nDigits - 1 - std::log10(std::abs(fValue)))), fValue); Просто опечатка.     
 ^c574749188

---



|         #         |              Дата              |                     Автор                     |           ID           |
| --- | --- | --- | --- |
| (4/6) | 2011-11-18, 08:00 | zHz00 | c574752964 |

  
  **Гость**  , прошу прощения, в посте обнаружена опечатка. там не БОЛЬШЕ FLT\_MIN, а МЕНЬШЕ!   
 Опечатка связана с тем, что движок дайари пытался парсить знак больше как хтмл и я заменил его, а при замене перепутал & gt; и & lt;.   
 Я дико извиняюсь.   
   
 За упрощения спасибо.   
   
 На главный вопрос, что же делает этот кусок, пока ответа нет.   
 ^c574752964

---



|         #         |              Дата              |                     Автор                     |           ID           |
| --- | --- | --- | --- |
| (5/6) | 2011-11-18, 22:55 | Гость | c574852226 |

  
  [читать дальше](https://zHz00.diary.ru/p169376440.htm?index=1#linkmore169376440m1)    Оххх.. я до 5 утра ломал голову над тем что происходит со «средними» числами. В таком случае ответ очень простой: вывод чисел в одинаковой ширины (скорее всего в столбик), но без искажений (существенных).   
   
 Что-то типа   
 123400000123401234123.412.341.2340.12340.012340.00000000001234   
   
 Правда, обычно (если конечно времени достаточно), это делается немного по-другому: проходим по всем числам без унизительной процедуры обрезания и ищем максимальную ширину (промежуточные результаты при этом могут сохраняться), затем проходим второй раз и выводим числа, дополняя их нужным количеством пробелов.     
   
 // коль уж я решил в этом треде не светить своего ника, то я позволю себе остаться 99% анонимусом до самого конца   
 ^c574852226

---



|         #         |              Дата              |                     Автор                     |           ID           |
| --- | --- | --- | --- |
| (6/6) | 2011-11-18, 23:04 | zHz00 | c574853487 |

  
  **Гость**  ,  [читать дальше](https://zHz00.diary.ru/p169376440.htm?index=1#linkmore169376440m1)    что значит "одинаковой ширины"?     
 ^c574853487