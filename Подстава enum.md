Подстава enum
==============

   
 2020-11-05, 23:59   
  Я привык к старым дефайн-константам. Они простые как валенок и привычные. Но есть более прогрессивный тип -- enum. Вы как бы об'являете сразу кучу констант и тип, которому можно присваивать только одну из них. Численные значения присваиваются автоматически, хотя можно задать вручную. Я не буду расписывать подробно синтаксис.   
   
 Подстава в том, что идентификаторы енума имеют глобальную область видимости, поэтому они не могут повторяться. Сделав парочку похожих енумов с совпадающими названиями я обнаружил, что это не компилируется. Поэтому я воспользовался дедовским способом, ввёл префиксы в названиях констант енума.   
   
 Итак, у меня был енум-тип, имеющий типичное назначение -- обозначать один тип данных из нескольких.   
   
 
```
enum ValType  
{<br>	VT\_BYTE,<br>	VT\_INT,<br>	VT\_FLOAT,<br>	VT\_STRING  
};
```
   
   
 Как видно, префиксы я ввёл. Но это меня не спасло. Код не компилировался. Мне компилятор сообщал, что VT\_INT уже об'явлён, причём предыдущее об'явление -- тоже енум! Но я такого нигде не писал. Тогда я... загуглил. И нашёл вот это:   
   
  [docs.microsoft.com/en-us/windows/win32/api/wtyp...](https://docs.microsoft.com/en-us/windows/win32/api/wtypes/ne-wtypes-varenum)    
   
 То есть, у винды уже оказался тип с похожим назначением. И у него оказалась константа с точно таким же именем, несмотря на то, что я ввёл префикс. Повезло!   
   
 Пришлось мне мою константу переименовать в VT\_INTEGER.   
   
 А ещё! В Си++11, оказывается, есть енумы с ограниченной областью видимости. Чтобы константы не конфликтовали, следует написать enum class вместо enum. Тогда доступ к константам будет только через ValType::VT\_BYTE и подобное.   
   
   **Пожалуйста, ознакомьтесь с комментариями!**     
    
 <https://diary.ru/~zHz00/p220107328_podstava-enum.htm>   
   
 Теги:   
 [[Программирование]]   
 ID: p220107328