signed char и шестнадцатеричное представление
==============================================

   
 2017-04-25, 23:59   
  Допустим, мы хотим увидеть char в шестнадцатеричном виде при помощи printf или аналогичной функции. Это бывает нужно для организации логирования дампов двоичных массивов при приёме/передаче данных, скажем.   
   
 Нас ждёт разочарование. char по умолчанию signed. Спецификатор для шестнадцатеричных чисел -- %x. Но он работает с числами размером с int. signed char будет преобразован в unsigned int, и все старшие биты будут забиты единичками из-за дополнительного кода. То есть, вместо 0x2F мы увидим 0xFFFFFF2F (при форматное строке "0x%02x").   
   
 Что же делать?   
 1. Забыть про массивы char. Использовать либо unsigned char, либо новомодный (лет пять-десять как) uint8\_t.   
 2. Использовать двойное преобразование типов. Это лол. Я не ожидал, что это сработает:   
   
 printf( "0x%02x ",(unsigned int)(unsigned char)buffer[offset]);   
    
 <https://diary.ru/~zHz00/p212618849_signed-char-i-shestnadcaterichnoe-predstavlenie.htm>   
   
 Теги:   
 [[Программирование]]   
 ID: p212618849